
<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>QObject类详解</title>
  <meta name="description" content="QObject类详解" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="../css/screen.css" />
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="Casper theme live demo">
</head>
<body class="post-template">
<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2017-05-16" itemprop="datePublished">2017-05-16 23:46:41</time>
       by <a href='http://loringfor.github.io' style='margin:0 5px;'>向玉林</a>
    </span> 
    <h1 class="post-title" align="center">QObject类详解</h1>
    <section class="post-content">
</br>
<h3 id="qobjectqt所有类的基类" align="center">QObject——Qt所有类的基类</h3>
<p>在Qt中，所有的类都继承自QObject类，QObject里面到底有什么呢？下面是我的学习笔记</p>
<p>对于具体什么是QObject，主要包括如下的内容：</p>
<ol style="list-style-type: decimal">
<li>信号和槽</li>
<li>良好的对象属性，如可查询等</li>
<li>有力的事件和事件过滤器</li>
<li>国际化字符设计</li>
<li>定时器为GUI的事件提供毫秒级的支持</li>
<li>很优秀的对象树结构</li>
<li>当对象销毁时指针自动设置为0</li>
<li>动态类型转换</li>
</ol>
<p><strong>详细描述</strong>（抄录于<a href="http://doc.qt.io/qt-5/qobject.html"><font color="green">官方文档</font></a>）</p>
<ol style="list-style-type: decimal">
<li>QObject类是所有Qt对象的基类。</li>
<li>QObject是Qt对象模型的中心。这个模型的中心特征就是一种用于无缝对象通讯的被叫做信号和槽的非常强大的机制。你能够使用connect()把信号和槽连接起来并且可以用disconnect()来破坏这种连接。为了避免从不结束的通知循环，你可以调用blockSignals()临时地阻塞信号。保护函数connectNotify()和disconnectNotify()使跟踪连接成为可能。</li>
<li>QObject把它们自己组织在对象树中。当你创建一个QObject作为其它对象的父对象，这个对象会在父对象中自动调用insertChild()并且可以在父对象的children()列表中显示出来。父对象拥有这个对象，比如，它将在它的析构函数中自动删除它的孩子。你可以使用child()或者queryList()通过名称和任意的类型来查找一个对象，并且使用objectTrees()来获得树根的列表。</li>
<li>每个对象都有一个对象名称（name()），能够报告它的类名（className()）并且它在QObject继承层次中是否继承了另一个类（inherits()）。</li>
<li>当对象被删除时，它发射destroyed()信号。你可以捕获这个信号来避免对QObject的摇摆引用。QGuardedPtr类提供了一种文雅的方式来使用这个机制。</li>
<li>QObject可以通过event()接收事件并且过滤其它对象的事件。详细情况请参考installEventFilter()和eventFilter()。一个方便的处理者，childEvent()，能够被重新实现来捕获子对象事件。</li>
<li>最后但不是最不重要的一点，QObject提供了Qt中最基本的定时器，关于定时器的高级支持请参考QTimer。</li>
<li>注意Q_OBJECT宏对于任何实现信号、槽和属性的对象都是强制的。你也需要对源文件运行moc程序（元对象编译器）。我们强烈建议在QObject的所有子类中使用这个宏，而不管它是不是实际使用了信号、槽和属性，因为不这样做也许会导致普通函数会出现为定义的问题。</li>
<li>所有的Qt窗口部件继承了QObject。方便的函数isWidgetType()返回这个对象实际上是不是一个窗口部件。它比inherits( &quot;QWidget&quot; )快得多。</li>
<li>一些QObject函数，比如children()、objectTrees()和queryList()返回一个QObjectList。QObjectList是QObject的QPtrList。QObjectLists支持像QPtrLists同样的操作并且又一个迭代器类QObjectListIt。</li>
</ol>
<p>既然QObject是所有类的基类，那么这个类必须要绝对抽象，只有这样所有的类才会继承里面有用的东西。信号和槽是Qt特有的通信机制，也是Qt的特色，所有的类都支持信号和槽机制，所以在QObject里面信号和槽将会实现。如下图，这是QObject类的所有成员函数：</p>
<div class="figure">
<img src="../images/QObject.png" />

</div>
<p>可以看出，里面主要是实现connect函数和disconnect函数，我们可以通过connect()连接一个信号到槽，并通过disconnect()来解除这个连接，临时中断用blockSignals()，还可以用 connectNotify()和disconnectNotify()来监听一个连接状态。对于connect和disconnect有很多重载函数。</p>
<p>每个对象有个objectName()，他的类名可以在metaObject()找到，还可以用inherits()函数来检测他的继承关系</p>
	  <p>当一个对象销毁时发生信号 destroyed()</p></br>
<p>下面就来学习下里面的<strong>成员函数</strong>（只挑取里面重要的一些讲解）</p>

	  <ol style="list-style-type: decimal">
<li><p>首先是构造函数<code>QObject::QObject(QObject *parent = Q_NULLPTR) </code>构造一个父对象为parent，叫做name的对象。 对象的父对象也许可以看做这个对象的所有者。例如，一个对话框是它包含的“OK”和“Cancel”按钮的父对象。 设置parent为0时，构造一个没有父对象的对象。如果一个对象是窗口部件，它将会成为一个顶级窗口。 对象名称就是可以用来识别一个QObject的一些文本。它在和Qt设计器联合使用的时候特别有用。你可以使用child()来通过名称（和类型）找到一个对象。使用queryList()可以找到几个对象。</p></li>
<li><p><code>bool QObject :: blockSignals（bool block）</code> 如果块为真，则该对象发射的信号被阻塞（即发射信号将不会调用与之相连的任何信号）。如果block为false，则不会发生这种阻塞。 返回值是以前的signalsBlocked（）值。 请注意，即使该对象的信号已被阻止，destroy（）信号也将被发出。 阻塞时发出的信号不缓冲。</p></li>
<li><p><code>void QObject :: childEvent（QChildEvent * event）</code> 该事件处理程序可以在子类中重新实现以接收子事件。事件在事件参数中传递。 当添加或删除子项时，QEvent :: ChildAdded和QEvent :: ChildRemoved事件将发送到对象。在这两种情况下，您只能依靠孩子是QObject，或者ifWidgetType（）返回true一个QWidget。（这是因为在ChildAdded的情况下，该孩子尚未完全构建，而在ChildRemoved的情况下，它可能已被破坏）。 QEvent :: ChildPolished事件发送到小部件，当孩子被抛光时，或者当抛光的孩子被添加。如果您收到儿童抛光活动，孩子的建设通常会完成。但是，这不能保证，并且在执行窗口小部件的构造函数期间可能会传送多个抛光事件。 对于每个子窗口小部件，您将收到一个ChildAdded事件，零个或多个ChildPolished事件和一个ChildRemoved事件。 该ChildPolished如果一个孩子被删除添加后立即被忽略的事件。如果一个孩子在施工和销毁期间抛光了好几次，您可能会收到同一个孩子的几个儿童抛光事件，每次都有不同的虚拟桌面。</p></li>
<li><p><code>bool QObject::connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member )</code> 把从sender对象发送的signal和receiver对象中的member连接起来，并且如果连接成功返回真，否则返回假。在实际运用中，我们会用到两个宏：SIGNAL() 和SLOT()；在这里函数的声明中，我们可以看出通过connect声明这两个宏最后得到一个const char*类型。 在qobjectdefs.h中可以看到SIGNAL() 和SLOT()的宏定义： #ifndef QT_NO_DEBUG<br />
<pre><code>#define QLOCATION &quot;&quot;<strong>FILE</strong>&quot;:&quot;QTOSTRING(<strong>LINE</strong>)<br />
#define METHOD(a) qFlagLocation(&quot;0&quot;#a QLOCATION)<br />
#define SLOT(a) qFlagLocation(&quot;1&quot;#a QLOCATION)<br />
#define SIGNAL(a) qFlagLocation(&quot;2&quot;#a QLOCATION)<br />
#else<br />
#define METHOD(a) &quot;0&quot;#a<br />
#define SLOT(a) &quot;1&quot;#a<br />
#define SIGNAL(a) &quot;2&quot;#a<br /></code></pre>
#endif 所以这两个宏的作用就是把函数名转换为字符串并且在前面加上标识符。 一个信号也可以被连接到另一个信号上： 一个信号可以被连接到多个槽和信号上。多个信号可以被连接到一个槽上。 如果一个信号被连接到几个槽上，当信号被发射的时候，槽被激活的顺序是任意的。 如果信号和槽被成功连接，返回真。如果它不能创建连接，返回假，例如，如果QObject不能检验signal或member的存在，或者如果它们的标签不协调。</p></li>
	
<p>看到这里，你可能会问了，这个QObject类里面只有这个connect函数的声明，到底是怎么实现信号和槽机制的呢？其实在开始学习的时候，对于这个问题我也是很不清楚。这里就要提到QMetaObject元对象了，凡是需要使用信号和槽机制就必须声明Q_OBJECT宏，声明这个宏后，在编译的时候会先采用moc将Q_OBJECT宏展开到相应的文件，这里面会将Qt拓展的东西全部加进去，链接的时候也会加进去，具体如何在这个文件里面如何实现了信号和槽机制，这个可以参考我的上一篇文章，我对moc生成的文件进行了一个剖析。</p>
</ol>
	
	
	<ol start="5" style="list-style-type: decimal">
<li><code>void QObject::connectNotify ( const char * signal )</code></li>
<p>当某个东西被连接到这个对象的signal时，这个虚函数被调用。</p>
<p>警告：这个函数违反了模块的面向对象的原则。不管如何，当你需要在某个东西连接到一个信号时执行昂贵的初始化时，这也许很有用。</p></ol>

	<ol start="6" style="list-style-type: decimal">
<li><p><code>void QObject::customEvent(QEvent *event)</code> 此事件处理程序可以在子类中重新实现以接收自定义事件。 自定义事件是类型值至少与QEvent :: Type枚举的QEvent :: User项一样大的用户定义事件，通常是一个QEvent子类。 事件在事件参数中传递。</p></li>
<li><p><code>void QObject::deleteLater ()</code> 执行这个对象的延期删除。 不是立即删除，这个函数当Qt返回主事件循环时延期执行删除事件的处理。</p></li>
<li><p><code>void QObject::destroyed ()</code> 在对象被销毁之前，这个信号被立即发射。 在这个信号被发射之后，所有这个对象的子对象都被销毁。</p></li>
<li><p><code>bool QObject::disconnect ( const QObject * sender, const char * signal, const QObject * receiver, const char * member )</code></li>
取消从sender对象发送的signal和对象receiver中的member的连接。 当这两个有关对象中的一个被销毁时，这个信号——槽连接就被移除了。 其实这个函数一般很少用到，因为当对象析构时，连接会自动移除的。</br>
disconnect()通常被用在三种方式下，正如下面的例子所描述的。 </br>
(1).取消连接到一个对象的信号的任何事物:<code>disconnect( myObject, 0, 0, 0 )</code>;
等于非静态重载函数<code>myObject->disconnect()</code>;<br />
(2).取消连接到一个特定信号的任何事物:<code>disconnect( myObject, SIGNAL(mySignal()), 0, 0 )</code>;
等于非静态重载函数<code>myObject->disconnect( SIGNAL(mySignal()) )</code>;<br />
(3).取消一个特定接收者的所有连接:<code>disconnect( myObject, 0, myReceiver, 0 )</code>;
等于非静态重载函数<code>myObject->disconnect( myReceiver )</code>;<br />
0可以用做一个通配符，意义可能分别为“任何信号”、“任何接受对象”或者“一个接受对象中的任何槽”。 sender不能为0。（你不能在一个调用中取消来自多于一个对象的信号的连接。） 如果signal为0，它取消所有和这个对象的信号连接的receiver和member。如果不是，只由特定信号被取消联接。</p>
<p>  如果receiver为0，它取消连接到signal的任何事物。如果不是，只有receiver中的槽被取消连接。 如果member为0，它取消连接到receiver的任何事物。如果不是，只有名为member的槽被取消联接并且其它所有槽被保留。如果receiver被省去，member必须为0，所以你不能取消所有对象中同一特定名称槽的连接。</p></ol>

<ol start="10" style="list-style-type: decimal">
<li><p><code>void QObject::dumpObjectInfo ()</code>和<code>void QObject::dumpObjectTree ()</code> 调试输出这个对象的关于信号连接的消息等和调试输出子对象树。 在调试的时候这两个函数很有用，但是如果库是在发布模式下（例如，没有任何调试信息）被编译的，它就不会做任何事情。</p></li>
<li><p><code>bool QObject::event ( QEvent * e )</code> 这个虚函数会接收到一个对象的事件并且应该在e事件被识别和处理时返回真。 event()可以被重新实现来定义一个对象的行为。</p></li>
<li><p><code>bool QObject::eventFilter ( QObject * watched, QEvent * e )</code> 如果这个对象已经被安装为watched对象的一个事件过滤器，就过滤事件。 在这个函数你的重新实现中，如果你想过滤出e事件，比如，停止它的进一步处理，返回真，否则返回假。 警告：如果你在这个函数中删除接收对象，请确认返回真。否则，Qt会把这个事件转给被删除的对象并且程序也许会崩溃。</p></li>
<li><p><code>T findChild(const QString &amp;, Qt::FindChildOptions ) const</code> 找出子类，没有找到返回0，可以分为： a.找特定的子类 b.找所有的同一类别子类</p></li>
<li><p><code>void QObject::killTimer ( int id )</code> 通过定时器标识符id删除定时器。 当一个定时器事件开始时，定时器标识符由startTimer()返回。 void QObject::killTimers () 删除这个对象中已经开始的所有定时器。</p></li>
<li><p><code>QMetaObject * QObject::metaObject () const</code> 返回这个对象的元对象的指针。 元对象包含关于一个继承QObject的类的一些信息，比如，类名称、超类名称、属性、信号和槽。每个包含Q_OBJECT宏的类也都会有一个元对象。 在信号/槽连接机制和属性系统中需要元对象信息。函数isA()和inherits()也使用元对象。</p></li>
<li><p><code>QObject * QObject::parent () const</code> 返回父对象的指针。可以参考children()。</p></li>
<p><code>QVariant QObject::property ( const char * name ) const</code> 返回对象的name属性的值。 如果没有这样一个属性存在，返回变量是无效的。</p></ol>

<ol start="17" style="list-style-type: decimal">
<li><code>int receivers(const char *) const</code> 返回连接到信号的接收器的数量。 由于这两个时隙和信号都可以用作信号的接收机，并且可以进行相同的连接多次，所以接收机的数量与从该信号进行的连接数相同。 调用此函数时，可以使用SIGNAL（）宏传递特定信号。</li>
</ol>
<p><code>const QObject * QObject::sender ()</code> 如果在任何函数调用或信号发射之前在槽中调用的话，返回发送消息的对象的指针。在所有其它情况下，返回未定义的值。</p>

	<ol start="18" style="list-style-type: decimal">
<li><p><code>int QObject::startTimer ( int interval )</code> 定时器开始计时并且返回一个定时器标识符，或者如果不能开始计时，返回0。 每interval毫秒出现一个定时器事件直到killTimer()或killTimers()被调用。如果interval为0，那么定时器事件将在每次没有窗口系统事件要处理的情况下出现。 当定时器事件发生时，虚函数timerEvent()被调用为QTimerEvent事件参数类。重新实现这个函数可以获得定时器事件。 如果多个定时器在运行，QTimerEvent::timerId()可以用来找到那个定时器被激活。 实例：
<pre><code>class MyObject : public QObject
    {
        Q_OBJECT
    public:
        MyObject( QObject *parent = 0, const char *name = 0 );

    protected:
        void timerEvent( QTimerEvent * );
    };

    MyObject::MyObject( QObject *parent, const char *name )
        : QObject( parent, name )
    {
        startTimer( 50 );    // 50微妙定时器
        startTimer( 1000 );  // 1秒定时器
        startTimer( 60000 ); // 1分钟定时器
    }

    void MyObject::timerEvent( QTimerEvent *e )
    {
        qDebug( "timer event, id %d", e->timerId() );
    }</code></pre>	
	</li>
</ol>
	
<p>实际上没有间隔值的上限（超过1年也可以）。注意QTimer的精确度依赖与底下的操作系统和硬件。绝大多数平台都支持20毫秒的精确度，一些平台可以提供更精确的。如果Qt不能发送定时器滴答所要求的数量，它将会默默地丢弃一些。 QTimer类提供了单触发定时器和替代事件的定时器信号的高级编程接口。</p>

	<ol start="19" style="list-style-type: decimal">
<li><p><code>void QObject::timerEvent ( QTimerEvent * ) </code>这个信号处理者可以在子类中重新实现而接收对象的定时器事件。 QTimer提供了定时器功能的高级接口，并且提供了关于定时器的更多说明。</p></li>
<li><p><code>QString QObject::tr ( const char * sourceText, const char * comment ) const</code> 其实就可以把这个函数当做一个翻译，把中文翻译成指定的类型，不发生中文显示乱码的现象。返回sourceText的翻译版本，或者如果没有合适的版本返回sourceText它自己。翻译上下文是comment的QObject（默认为空）。所有使用Q_OBJECT宏的QObject对象有这个函数的重新实现，把子类名作为上下文。</p></li>
</ol>
<p>对于QObject的成员函数就分析到了这里，其实QObject作为所有Qt函数的基类主要是来实现了Qt特有的信号和槽机制，需要对connect函数进行深入的理解。通过对QObject的学习还会发现很多东西，
	因为和它想联系的东西太多，当然还有QObject的宏将在下一篇文章中学习。当然如果想详细了解QObject类，可以去看Qt的<a href="http://doc.qt.io/qt-5/qobject.html"><font color="green">官方文档</font></a></p>


    <footer class="post-footer">
      <section class="author">
        <h4>向玉林</h4>
      </section>

      <section class="share">
        <h4>Share this post</h4>
        <a class="icon-twitter" href="http://twitter.com/share?url=http://kywk.github.io/hexo-theme-casper/2014/02/20/casper-readme/"
          onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
          <span class="hidden">Twitter</span>
        </a>
        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://kywk.github.io/hexo-theme-casper/2014/02/20/casper-readme/"
          onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <span class="hidden">Facebook</span>
        </a>
        <a class="icon-google-plus" href="https://plus.google.com/share?url=http://kywk.github.io/hexo-theme-casper/2014/02/20/casper-readme/"
           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
          <span class="hidden">Google+</span>
        </a>
      </section>
    </footer>
  </article>
</main>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script type="text/javascript" src="../js/jquery.fitvids.js"></script>
<script type="text/javascript" src="../js/index.js"></script>
</body>
</html>
