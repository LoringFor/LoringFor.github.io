<p>对于上次关于什么是moc工具的时候，写了一篇小短文，但是当时概念还不是很清楚，对于为什么要声明Q_OBJECT这个宏还是不了解，经过几天的学习，对于这个有了新的了解，写篇小文章说说我的理解。</p>
<p>首先要弄清楚什么是<strong>元对象（QMetaObject）</strong>？</p>
<p>在计算机科学中，元对象是这样一个东西：它可以操纵，创建，描述，或执行其他对象。元对象描述的对象称为基对象。元对象可能存这样的信息：基础对象的类型，接口，类，方法，属性，变量，函数，控制结构等。</p>
<p>具体来说，QMetaObject是用来保存Qt元对象的元信息，当继承QObject类并使用宏Q_OBJECT时，创建的类产生一个静态QMetaObject实例staticMetaObject，这个实例会保存类名、信号名称及索引、槽的名字及索引等等在对象操作时需要的基本信息，而这也是信号与槽的根本所在。</p>
<p>QT中的<strong>元对象系统:</strong></p>
<p>QT中的元对象系统基于以下三种东西：</p>
<ol style="list-style-type: decimal">
<li><p>QObject 提到这个类，相信大家都不陌生。几乎所有在QT开发的类都继承于此类。 QObject这个类为其他需要用到元对象系统的类提供了一个基类。</p></li>
<li><p>Q_OBJECT 放在类声明中的Q_OBJECT宏是用来为这个类开启元对象特性的，例如动态的属性(dynamic properties)，信号(signals)以及槽(slots)。 可这个Q_OBJECT宏到底是什么呢？如下图所示，大家可以看到它是一些函数和一个静态的类成员。 Q_OBJECT宏内容如下： #define Q_OBJECT<br />
public:<br />
Q_OBJECT_CHECK<br />
static const QMetaObject staticMetaObject;<br />
Q_OBJECT_GETSTATICMETAOBJECT<br />
virtual const QMetaObject <em>metaObject() const;<br />
virtual void </em>qt_metacast(const char <em>);<br />
QT_TR_FUNCTIONS<br />
virtual int qt_metacall(QMetaObject::Call, int, void *</em>);<br />
private:</p></li>
</ol>
<p>而Q_OBJECT_CHECK宏的内容是： #define Q_OBJECT_CHECK<br />
template <typename T> inline void qt_check_for_QOBJECT_macro(const T &amp;_q_argument) const<br />
{ int i = qYouForgotTheQ_OBJECT_Macro(this, &amp;_q_argument); i = i; } 这里是检查类声明中是否遗漏Q_OBJECT宏，如果遗漏则在编译时给出错误提示。</p>
<p>而QT_TR_FUNCTIONS宏的内容是： # define QT_TR_FUNCTIONS<br />
static inline QString tr(const char <em>s, const char </em>c = 0)<br />
{ return staticMetaObject.tr(s, c); }<br />
static inline QString trUtf8(const char <em>s, const char </em>c = 0)<br />
{ return staticMetaObject.trUtf8(s, c); }<br />
static inline QString tr(const char <em>s, const char </em>c, int n)<br />
{ return staticMetaObject.tr(s, c, n); }<br />
static inline QString trUtf8(const char <em>s, const char </em>c, int n)<br />
{ return staticMetaObject.trUtf8(s, c, n); } 一些字符串操作的算法，这几个方法实际上是隐藏了父类QObject中这个几个方法。我们在类定义中调用的tr或是trUtf8方法都是调用这里的方法。</p>
<ol start="3" style="list-style-type: decimal">
<li>moc 什么是moc，moc工具有什么用，这个在moc的作用这篇文章里面已经解释过了，这里简单介绍下。 就是当moc工具读取一个c++源文件时，如果它发现类的声明中有Q_OBJECT时，它会产生另外一个c++源文件，这个文件中就包含了这些类的元对象代码。这个新产生的文件可以以#include形式包含到这个类的源文件中，但更常用的做法是和这个类的定义一起编译连接。</li>
</ol>
<p>现在我自己创建一个Mainwindow类，此类继承自QMainwindow类，在mainwindow.h里面编写代码如下，其中声明了三个信号，三个槽函数。</p>
<h1 id="ifndef-mainwindow_h">ifndef MAINWINDOW_H</h1>
<h1 id="define-mainwindow_h">define MAINWINDOW_H</h1>
<h1 id="include">include <QMainWindow></h1>
<h1 id="include-1">include <QString></h1>
<p>namespace Ui { class MainWindow; }</p>
<p>class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget <em>parent = 0); ~MainWindow(); public slots: void slotTest1(int value); void slotTest2(const QString value); void slotTest3(bool value); signals: void signalTest1(int value); void signalTest2(const QString value); void signalTest3(bool value); public: void test(); private: Ui::MainWindow </em>ui; }; #endif // MAINWINDOW_H</p>
<p>在该目录下，在命令行输入 moc mainwindow.h -o moc_mainwindow.h生成了moc_mianwindow.h文件，打开此文件，让我们一起分析下此文件里面的内容：</p>
<p>/**************************************************************************** ** Meta object code from reading C++ file 'mainwindow.h' <strong> </strong> Created by: The Qt Meta Object Compiler version 67 (Qt 5.6.1) <strong> </strong> WARNING! All changes made in this file will be lost! *****************************************************************************/</p>
<p>//先看看的一些预处理，不少的include、if 和error： #include &quot;mainwindow.h&quot; #include <QtCore/qbytearray.h> #include <QtCore/qmetatype.h> #if !defined(Q_MOC_OUTPUT_REVISION) #error &quot;The header file 'mainwindow.h' doesn't include <QObject>.&quot; #elif Q_MOC_OUTPUT_REVISION != 67 #error &quot;This file was generated using the moc from 5.6.1. It&quot; #error &quot;cannot be used with the include files from this version of Qt.&quot; #error &quot;(The moc has changed too much.)&quot; #endif</p>
<p>/<em>接着是一个宏QT_BEGIN_MOC_NAMESPACE 在qglobal.h我们可以找到如下： # define QT_BEGIN_MOC_NAMESPACE QT_USE_NAMESPACE # define QT_USE_NAMESPACE using namespace :: QT_NAMESPACE; 所以QT_BEGIN_MOC_NAMESPACE就是using namespace :: QT_NAMESPACE;现在看起来感觉熟悉多了。 当然和它的配对的一项QT_END_MOC_NAMESPACE也看一下： 在qglobal.h我们可以找到如下： # define QT_END_MOC_NAMESPACE 它就是一个空的，什么也没有，仅仅是为了配对，看起来比较好看吧。</em>/ QT_BEGIN_MOC_NAMESPACE</p>
<p>//函数名信息结构体 /* data字段是一个由byte数组组成的数组，数组大小根据信号&amp;槽个数有关，这个数组在调用QObject的connect函数时用来匹配信号名或槽名。 stringdata 存放的是字符资源，存放全部的信号名、槽名、类名。 <em>/ struct qt_meta_stringdata_MainWindow_t { QByteArrayData data[9]; char stringdata0[84]; }; #define QT_MOC_LITERAL(idx, ofs, len)<br />
Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len,<br />
qptrdiff(offsetof(qt_meta_stringdata_MainWindow_t, stringdata0) + ofs<br />
- idx </em> sizeof(QByteArrayData))<br />
)</p>
<p>//函数名信息结构体 对象 static const qt_meta_stringdata_MainWindow_t qt_meta_stringdata_MainWindow = { { QT_MOC_LITERAL(0, 0, 10), // &quot;MainWindow&quot; QT_MOC_LITERAL(1, 11, 11), // &quot;signalTest1&quot; QT_MOC_LITERAL(2, 23, 0), // &quot;&quot; QT_MOC_LITERAL(3, 24, 5), // &quot;value&quot; QT_MOC_LITERAL(4, 30, 11), // &quot;signalTest2&quot; QT_MOC_LITERAL(5, 42, 11), // &quot;signalTest3&quot; QT_MOC_LITERAL(6, 54, 9), // &quot;slotTest1&quot; QT_MOC_LITERAL(7, 64, 9), // &quot;slotTest2&quot; QT_MOC_LITERAL(8, 74, 9) // &quot;slotTest3&quot; }, &quot;MainWindowsignalTest1valuesignalTest2&quot; &quot;signalTest3slotTest1slotTest2&quot; &quot;slotTest3&quot; }; #undef QT_MOC_LITERAL</p>
<p>//描述信号槽在调用时的索引，参数，返回值等信息 /<em>你写的每个类，只要是从QObject继承，并且在类的声明中包含Q_OBJECT宏， moc都会为了定义一个（qt_meta_data_+类名）格式的静态变量。 content描述了一些基本参数，然后的四项分别是信号和槽的名字和参数。</em>/ static const uint qt_meta_data_MainWindow[] = { // content: 7, // revision 0, // classname 0, 0, // classinfo 6, 14, // methods,信号和槽的总个数，在表中的偏移量,即14个uint之后是信号和槽的信息 0, 0, // properties 0, 0, // enums/sets 0, 0, // constructors 0, // flags 3, // signalCount</p>
<p>// signals: name, argc, parameters, tag, flags</p>
<p>//name：名称；argc：参数个数</p>
<p>//parameters：参数的在 qt_meta_data_MainWindow 这个表中的索引位置，就是下面的signals:parrment</p>
<p>// tag: 对应的是 qt_meta_data_MainWindow 索引</p>
<p>//flags：特征值，访问权限标识,信号还是槽的标志相或得到的 1, 1, 44, 2, 0x06 /* Public <em>/, 4, 1, 47, 2, 0x06 /</em> Public <em>/, 5, 1, 50, 2, 0x06 /</em> Public */,</p>
<p>// slots: name, argc, parameters, tag, flags 6, 1, 53, 2, 0x0a /* Public <em>/, 7, 1, 56, 2, 0x0a /</em> Public <em>/, 8, 1, 59, 2, 0x0a /</em> Public */,</p>
<p>// signals: parameters QMetaType::Void, QMetaType::Int, 3, QMetaType::Void, QMetaType::QString, 3, QMetaType::Void, QMetaType::Bool, 3,</p>
<p>// slots: parameters QMetaType::Void, QMetaType::Int, 3, QMetaType::Void, QMetaType::QString, 3, QMetaType::Void, QMetaType::Bool, 3, 0 // eod };</p>
<p>/<em>元对象调用入口，通过索引调用函数 这时是QT信号槽原理实现很重要的一步， 这里_id就是信号槽对应的索引，可每个信号或是槽对应哪个索引呢， 看看它的元字符串数据qt_meta_stringdata_MainWindow，应该就知道了</em>/ void MainWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a) { if (_c == QMetaObject::InvokeMetaMethod) { MainWindow *_t = static_cast<MainWindow *>(_o); Q_UNUSED(_t) switch (_id) { case 0: _t-&gt;signalTest1((<em>reinterpret_cast&lt; int(</em>)&gt;(_a[1]))); break; case 1: _t-&gt;signalTest2((<em>reinterpret_cast&lt; const QString(</em>)&gt;(_a[1]))); break; case 2: _t-&gt;signalTest3((<em>reinterpret_cast&lt; bool(</em>)&gt;(_a[1]))); break; case 3: _t-&gt;slotTest1((<em>reinterpret_cast&lt; int(</em>)&gt;(_a[1]))); break; case 4: _t-&gt;slotTest2((<em>reinterpret_cast&lt; const QString(</em>)&gt;(_a[1]))); break; case 5: _t-&gt;slotTest3((<em>reinterpret_cast&lt; bool(</em>)&gt;(_a[1]))); break; default: ; } } else if (_c == QMetaObject::IndexOfMethod) { int *result = reinterpret_cast<int *>(_a[0]); void **func = reinterpret_cast<void **>(_a[1]); { typedef void (MainWindow::*_t)(int ); if (*reinterpret_cast&lt;_t *&gt;(func) == static_cast&lt;_t&gt;(&amp;::signalTest1)) { <em>result = 0; return; } } { typedef void (MainWindow::</em>_t)(const QString ); if (*reinterpret_cast&lt;_t *&gt;(func) == static_cast&lt;_t&gt;(&amp;::signalTest2)) { <em>result = 1; return; } } { typedef void (MainWindow::</em>_t)(bool ); if (*reinterpret_cast&lt;_t *&gt;(func) == static_cast&lt;_t&gt;(&amp;::signalTest3)) { *result = 2; return; } } } }</p>
<p>/<em>静态元对象，包含了函数名信息结构体,主要包含三项： 1. 它的父类的静态元对象。 2. 它的元字符串数据。 3. 它的元数据。 保存了moc文件的信号和槽的调用索引信息。 在信号和槽绑定的时候就是通过这些信息一步一步建立的绑定关系</em>/ const QMetaObject MainWindow::staticMetaObject = { { &amp;::staticMetaObject, qt_meta_stringdata_MainWindow.data, qt_meta_data_MainWindow, qt_static_metacall, Q_NULLPTR, Q_NULLPTR} };</p>
<p>//返回一个元对象 const QMetaObject *MainWindow::metaObject() const { return QObject::d_ptr-&gt;metaObject ? QObject::d_ptr-&gt;dynamicMetaObject() : &amp;; }</p>
<p>//元对象中的字符数据转换，通过比较类的元字符串数据，如果相等则当前的this指针转换为空指针返回， //否则继续向上找，如果最顶上的类的元字符串数据还是不相同则返回空指针。 void <em>MainWindow::qt_metacast(const char </em>_clname) { if (!_clname) return Q_NULLPTR; if (!strcmp(_clname, qt_meta_stringdata_MainWindow.stringdata0)) return static_cast<void*>(const_cast&lt; MainWindow*&gt;(this)); return QMainWindow::qt_metacast(_clname); }</p>
<p>//元对象调用上层入口，槽函数调用从这个函数开始 int MainWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a) { _id = QMainWindow::qt_metacall(_c, _id, _a); if (_id &lt; 0) return _id; if (_c == QMetaObject::InvokeMetaMethod) { if (_id &lt; 6) qt_static_metacall(this, _c, _id, _a); _id -= 6; } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) { if (_id &lt; 6) *reinterpret_cast<int*>(_a[0]) = -1; _id -= 6; } return _id; }</p>
<p>//信号的实现 // SIGNAL 0 void MainWindow::signalTest1(int _t1) { void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&amp;_t1)) }; QMetaObject::activate(this, &amp;staticMetaObject, 0, _a); }</p>
<p>// SIGNAL 1 void MainWindow::signalTest2(const QString _t1) { void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&amp;_t1)) }; QMetaObject::activate(this, &amp;staticMetaObject, 1, _a); }</p>
<p>// SIGNAL 2 void MainWindow::signalTest3(bool _t1) { void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&amp;_t1)) }; QMetaObject::activate(this, &amp;staticMetaObject, 2, _a); } QT_END_MOC_NAMESPACE</p>
