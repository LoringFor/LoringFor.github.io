
<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>moc的作用</title>
  <meta name="description" content="moc的作用" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="../css/screen.css" />
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="Casper theme live demo">
</head>
<body class="post-template">
<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2017-05-13" itemprop="datePublished">2017-05-13 17:22:37</time>
       by <a href='http://loringfor.github.io' style='margin:0 5px;'>向玉林</a>
    </span>
    <h1 class="post-title" align="center">moc的作用</h1>
    <section class="post-content">
		
 <p style="text-indent:2em">Qt不是使用的“标准的” C++ 语言，而是对其进行了一定程度的“扩展”。我们从Qt新增加的关键字就可以看出来：signals、slots 或者 emit。所以有人会觉得Qt 的程序编译速度慢，这主要是因为在Qt将源代码交给标准 C++ 编译器，如gcc之前，需要事先将这些扩展的语法去除掉。完成这一操作的就是 moc。</p>
<p style="text-indent:2em">moc 全称是 Meta-Object Compiler，也就是“元对象编译器”。Qt 程序在交由标准编译器编译之前，先要使用moc分析C++源文件。如果它发现在一个头文件中包含了宏 Q_OBJECT，则会生成另外一个C++源文件。这个源文件中包含了 Q_OBJECT宏的实现代码。这个新的文件名字将会是原文件名前面加上moc_构成。这个新的文件同样将进入编译系统，最终被链接到二进制代码中去。因此我们可以知道，这个新的文件不是“替换”掉旧的文件，而是与原文件一起参与编译。另外，我们还可以看出一点，moc的执行是在预处理器之前。因为预处理器执行之后，Q_OBJECT宏就不存在了。</p>
<p style="text-indent:2em">既然每个源文件都需要 moc 去处理，那么我们在什么时候调用了它呢？实际上，如果你使用 qmake 的话，这一步调用会在生成的 makefile 中展现出来。从本质上来说，qmake 不过是一个 makefile 生成器，因此，最终执行还是通过 make 完成的。</p>
<p>下面我们做个简单的测试，建立一个test.cpp文件，其中代码如下</p>
<pre>class Test : public QObject 
{ 
 Q_OBJECT 
public: 
 explicit Test(QObject *parent = 0); 
signals: 
public slots: 
}; </pre>
		<p>然后在该目录下的命令行下输入<code>moc test.cpp -o moc_test.cpp</code>生成不带Q_OBJECT的源文件,如下</p>
		
<pre><code>
 /****************************************************************************
** Meta object code from reading C++ file 'Test.cpp'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.6.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'Test.cpp' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.6.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
struct qt_meta_stringdata_Test_t {
    QByteArrayData data[1];
    char stringdata0[5];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_Test_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_Test_t qt_meta_stringdata_Test = {
    {
QT_MOC_LITERAL(0, 0, 4) // "Test"

    },
    "Test"
};
#undef QT_MOC_LITERAL
static const uint qt_meta_data_Test[] = {
 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void Test::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject Test::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_Test.data,
      qt_meta_data_Test,  qt_static_metacall, Q_NULLPTR, Q_NULLPTR}
};

const QMetaObject *Test::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *Test::qt_metacast(const char *_clname)
{
    if (!_clname) return Q_NULLPTR;
    if (!strcmp(_clname, qt_meta_stringdata_Test.stringdata0))
        return static_cast<void*>(const_cast< Test*>(this));
    return QObject::qt_metacast(_clname);
}

int Test::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return_id;
    return _id;
}
QT_END_MOC_NAMESPACE</code></pre>
	
<p style="text-indent:2em">可以看到，多了很多乱七八糟的东西，moc_test.cpp 里面为 Test 类增加了很多函数。然而，我们并没有实际写出这些函数，它是怎么加入类的呢？别忘了，我们还有 Q_OBJECT 这个宏呢！</p>
<p style="text-indent:2em">正是对 Q_OBJECT 宏的展开，使我们的 Test 类拥有了这些多出来的属性和函数。注意，QT_TR_FUNCTIONS 这个宏也是在这里定义的。也就是说，如果你要使用 tr() 国际化，就必须使用 Q_OBJECT 宏，否则是没有 tr() 函数的。这期间最重要的就是 virtual const QMetaObject *metaObject() const; 函数。这个函数返回 QMetaObject 元对象类的实例，通过它，你就获得了 Qt 类的反射的能力：获取本对象的类型之类，而这一切，都不需要 C++ 编译器的 RTTI 支持。Qt 也提供了一个类似 C++ 的 dynamic_cast() 的函数 qobject_case()，而这一函数的实现也不需要 RTTI。另外，一个没有定义 Q_OBJECT 宏的类与它最接近的父类是同一类型的。也就是说，如果 A 继承了 QObject 并且定义了 Q_OBJECT，B 继承了 A 但没有定义 Q_OBJECT，C 继承了 B，则 C 的 QMetaObject::className() 函数将返回 A，而不是本身的名字。因此，为了避免这一问题，所有继承了 QObject 的类都应该定义 Q_OBJECT 宏，不管你是不是使用信号槽。</p>
<p style="text-indent:2em">最后加上我的理解，moc就是把有qt语法的文件先去除qt的一些东西，然后把去除后的文件再给此C++的编译器编译，Q_OBJECT会加入很多东西，并且每一个要使用信号和槽的类都要声明这个宏，至于为什么要声明它，还不是很清楚，望其他人指教</p>
		
    <footer class="post-footer">
      <section class="author">
        <h4>向玉林</h4>
      </section>

      <section class="share">
        <h4>Share this post</h4>
        <a class="icon-twitter" href="http://twitter.com/share?url=http://kywk.github.io/hexo-theme-casper/2014/02/20/casper-readme/"
          onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
          <span class="hidden">Twitter</span>
        </a>
        <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://kywk.github.io/hexo-theme-casper/2014/02/20/casper-readme/"
          onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <span class="hidden">Facebook</span>
        </a>
        <a class="icon-google-plus" href="https://plus.google.com/share?url=http://kywk.github.io/hexo-theme-casper/2014/02/20/casper-readme/"
           onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
          <span class="hidden">Google+</span>
        </a>
      </section>
    </footer>
  </article>
</main>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script type="text/javascript" src="../js/jquery.fitvids.js"></script>
<script type="text/javascript" src="../js/index.js"></script>
</body>
</html>
